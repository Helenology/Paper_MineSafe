#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : 2024/3/6 13:43
# @Author  : Helenology
# @Site    : 
# @File    : cspca.py
# @Software: PyCharm


import numpy as np
from scipy.linalg import hadamard
import sys
sys.path.append("../robust-pca-master/")
from r_pca import R_pca


class CSPCA:
    def __init__(self, X, Phi):
        self.X = X                 # the shape is (N, D)
        self.N = self.X.shape[0]
        self.D = self.X.shape[1]

        # Part A: CS Surveillance Video Acquisition
        self.Phi = Phi             # measurement matrix Φ with shape (P, D)
        self.Y = np.dot(self.X, np.transpose(self.Phi))  # CS measurement vectors $y_t = \Phi x_t$ from (18)

    @staticmethod
    def generate_measurement_matrix(k, P, D, seed=0):
        """
        On page 354 of manuscript ``Compressed-Sensed-Domain L1-PCA Video Surveillance"

        Φ is generated by randomly permuting the columns of an order-k, k ≥ D
         and multiple-of-four, Walsh-Hadamard (WH) matrix followed by
         arbitrary selection of P rows from the k available WH rows
         (if k > D, only D arbitrary columns are utilized)

        :param k: the order of the MH matrix, which must be a power of 2 (Otherwise, there will be a ValueError)
        :param P: the reduced dimension (P < D)
        :param D: the original dimension (P < D)
        :param seed: random seed; default is 0
        :return: the measurement matrix Φ
        """
        assert D <= k                # order-k, k ≥ D
        assert k % 4 == 0            # multiple-of-four

        np.random.seed(seed)         # fix the random seed
        Phi = hadamard(k)            # WH matrix
        row_idx = np.random.choice(Phi.shape[0], P, replace=False)  # randomly select P rows
        Phi = Phi[row_idx, :]        # maintain P randomly selected rows
        if k > D:                    # if the columns are redundant
            col_idx = np.random.choice(Phi.shape[1], D, replace=False)  # randomly select D rows
            Phi = Phi[:, col_idx]    # maintain D randomly selected cols
        return Phi

    # @staticmethod
    # def frobenius_norm(M):
    #     return np.linalg.norm(M, ord='fro')

    # @staticmethod
    # def shrink(M, tau):
    #     return np.sign(M) * np.maximum((np.abs(M) - tau), np.zeros(M.shape))

    # def svd_threshold(self, M, tau):
    #     U, S, V = np.linalg.svd(M, full_matrices=False)  # U:(n1, n1); S:vector; V:(n2, n2)
    #     return np.dot(U, np.dot(np.diag(self.shrink(S, tau)), V))

    def L1_PCA(self):
        """
        Here, we implement the L1-PCA by directly using the RPCA algorithm.
        :return:
        """
        rpca_model = R_pca(self.Y)
        L, S = rpca_model.fit(max_iter=100, iter_print=50)
        return L

    def reconstruct_L(self, Y_L):
        pass

    def reconstruct_X(self):
        pass

    def fit(self, tol=None, max_iter=1000, iter_print=100):
        # Part B: L1-PCA for Background Extraction
        Y_L = self.L1_PCA()          # background-scene subspace basis from (22)
        L = self.reconstruct_L(Y_L)  # frame-by-frame background scene reconstruction from (24)

        # Part C: Moving Object Extraction
        X = self.reconstruct_X()                    # frame-by-frame CS reconstruction from (27)
        E = X - L                                   # sparse foreground (moving object) from (28)
        return X


